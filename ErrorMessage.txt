> MarginalChangePoint <- stan(file = 'Model_changePointContinuous.stan',
+ data = continuous_data,
+ iter = 10, chains = 4)
      1 [main] make (984) c:\Rtools\bin\make.exe: *** fatal error - cygheap base mismatch detected - 0xC47408/0xBB7408.
This problem is probably due to using incompatible versions of the cygwin DLL.
Search for cygwin1.dll using the Windows Start->Find/Search facility
and delete all but the most recent version.  The most recent version *should*
reside in x:\cygwin\bin, where 'x' is the drive on which you have
installed the cygwin distribution.  Rebooting is also suggested if you
are unable to find another cygwin DLL.
      1 [main] make 5600 fork: child -1 - forked process 984 died unexpectedly, retry 0, exit code 0xC0000142, errno 11
make: vfork: Resource temporarily unavailable
Warning message:
running command 'make -f "C:/PROGRA~1/R/R-32~1.3/etc/x64/Makeconf" -f "C:/PROGRA~1/R/R-32~1.3/share/make/winshlib.mk" SHLIB_LDFLAGS='$(SHLIB_CXXLDFLAGS)' SHLIB_LD='$(SHLIB_CXXLD)' SHLIB="filec9c6965573f.dll" WIN=64 TCLBIN=64 OBJECTS="filec9c6965573f.o"' had status 2 

ERROR(s) during compilation: source code errors or compiler configuration errors!

Program source:
  1: 
  2: // includes from the plugin
  3: 
  4: 
  5: // user includes
  6: #define STAN__SERVICES__COMMAND_HPP// Code generated by Stan version 2.9
  7: 
  8: #include <stan/model/model_header.hpp>
  9: 
 10: namespace modelc9c67a11ebb_Model_changePointContinuous_namespace {
 11: 
 12: using std::istream;
 13: using std::string;
 14: using std::stringstream;
 15: using std::vector;
 16: using stan::io::dump;
 17: using stan::math::lgamma;
 18: using stan::model::prob_grad;
 19: using namespace stan::math;
 20: 
 21: typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
 22: typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
 23: typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;
 24: 
 25: static int current_statement_begin__;
 26: class modelc9c67a11ebb_Model_changePointContinuous : public prob_grad {
 27: private:
 28:     double r_e;
 29:     double r_l;
 30:     int T;
 31:     vector<double> D;
 32:     double log_unif;
 33: public:
 34:     modelc9c67a11ebb_Model_changePointContinuous(stan::io::var_context& context__,
 35:         std::ostream* pstream__ = 0)
 36:         : prob_grad(0) {
 37:         current_statement_begin__ = -1;
 38: 
 39:         static const char* function__ = "modelc9c67a11ebb_Model_changePointContinuous_namespace::modelc9c67a11ebb_Model_changePointContinuous";
 40:         (void) function__; // dummy call to supress warning
 41:         size_t pos__;
 42:         (void) pos__; // dummy call to supress warning
 43:         std::vector<int> vals_i__;
 44:         std::vector<double> vals_r__;
 45:         context__.validate_dims("data initialization", "r_e", "double", context__.to_vec());
 46:         r_e = double(0);
 47:         vals_r__ = context__.vals_r("r_e");
 48:         pos__ = 0;
 49:         r_e = vals_r__[pos__++];
 50:         context__.validate_dims("data initialization", "r_l", "double", context__.to_vec());
 51:         r_l = double(0);
 52:         vals_r__ = context__.vals_r("r_l");
 53:         pos__ = 0;
 54:         r_l = vals_r__[pos__++];
 55:         context__.validate_dims("data initialization", "T", "int", context__.to_vec());
 56:         T = int(0);
 57:         vals_i__ = context__.vals_i("T");
 58:         pos__ = 0;
 59:         T = vals_i__[pos__++];
 60:         context__.validate_dims("data initialization", "D", "double", context__.to_vec(T));
 61:         validate_non_negative_index("D", "T", T);
 62:         D = std::vector<double>(T,double(0));
 63:         vals_r__ = context__.vals_r("D");
 64:         pos__ = 0;
 65:         size_t D_limit_0__ = T;
 66:         for (size_t i_0__ = 0; i_0__ < D_limit_0__; ++i_0__) {
 67:             D[i_0__] = vals_r__[pos__++];
 68:         }
 69: 
 70:         // validate data
 71:         check_greater_or_equal(function__,"T",T,1);
 72:         log_unif = double(0);
 73: 
 74:         double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 75:         (void) DUMMY_VAR__;  // suppress unused var warning
 76: 
 77: 
 78:         // initialize transformed variables to avoid seg fault on val access
 79:         stan::math::fill(log_unif,DUMMY_VAR__);
 80: 
 81:         try {
 82:             current_statement_begin__ = 10;
 83:             stan::math::assign(log_unif, -(log(T)));
 84:         } catch (const std::exception& e) {
 85:             stan::lang::rethrow_located(e,current_statement_begin__);
 86:             // Next line prevents compiler griping about no return
 87: throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
 88:         }
 89: 
 90:         // validate transformed data
 91: 
 92:         // set parameter ranges
 93:         num_params_r__ = 0U;
 94:         param_ranges_i__.clear();
 95:         ++num_params_r__;
 96:         ++num_params_r__;
 97:         ++num_params_r__;
 98:     }
 99: 
100:     ~modelc9c67a11ebb_Model_changePointContinuous() { }
101: 
102: 
103:     void transform_inits(const stan::io::var_context& context__,
104:                          std::vector<int>& params_i__,
105:                          std::vector<double>& params_r__,
106:                          std::ostream* pstream__) const {
107:         stan::io::writer<double> writer__(params_r__,params_i__);
108:         size_t pos__;
109:         (void) pos__; // dummy call to supress warning
110:         std::vector<double> vals_r__;
111:         std::vector<int> vals_i__;
112: 
113:         if (!(context__.contains_r("e")))
114:             throw std::runtime_error("variable e missing");
115:         vals_r__ = context__.vals_r("e");
116:         pos__ = 0U;
117:         context__.validate_dims("initialization", "e", "double", context__.to_vec());
118:         double e(0);
119:         e = vals_r__[pos__++];
120:         try {
121:             writer__.scalar_unconstrain(e);
122:         } catch (const std::exception& e) { 
123:             throw std::runtime_error(std::string("Error transforming variable e: ") + e.what());
124:         }
125: 
126:         if (!(context__.contains_r("l")))
127:             throw std::runtime_error("variable l missing");
128:         vals_r__ = context__.vals_r("l");
129:         pos__ = 0U;
130:         context__.validate_dims("initialization", "l", "double", context__.to_vec());
131:         double l(0);
132:         l = vals_r__[pos__++];
133:         try {
134:             writer__.scalar_unconstrain(l);
135:         } catch (const std::exception& e) { 
136:             throw std::runtime_error(std::string("Error transforming variable l: ") + e.what());
137:         }
138: 
139:         if (!(context__.contains_r("sigma")))
140:             throw std::runtime_error("variable sigma missing");
141:         vals_r__ = context__.vals_r("sigma");
142:         pos__ = 0U;
143:         context__.validate_dims("initialization", "sigma", "double", context__.to_vec());
144:         double sigma(0);
145:         sigma = vals_r__[pos__++];
146:         try {
147:             writer__.scalar_lb_unconstrain(0,sigma);
148:         } catch (const std::exception& e) { 
149:             throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
150:         }
151: 
152:         params_r__ = writer__.data_r();
153:         params_i__ = writer__.data_i();
154:     }
155: 
156:     void transform_inits(const stan::io::var_context& context,
157:                          Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
158:                          std::ostream* pstream__) const {
159:       std::vector<double> params_r_vec;
160:       std::vector<int> params_i_vec;
161:       transform_inits(context, params_i_vec, params_r_vec, pstream__);
162:       params_r.resize(params_r_vec.size());
163:       for (int i = 0; i < params_r.size(); ++i)
164:         params_r(i) = params_r_vec[i];
165:     }
166: 
167: 
168:     template <bool propto__, bool jacobian__, typename T__>
169:     T__ log_prob(vector<T__>& params_r__,
170:                  vector<int>& params_i__,
171:                  std::ostream* pstream__ = 0) const {
172: 
173:         T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
174:         (void) DUMMY_VAR__;  // suppress unused var warning
175: 
176:         T__ lp__(0.0);
177:         stan::math::accumulator<T__> lp_accum__;
178: 
179:         // model parameters
180:         stan::io::reader<T__> in__(params_r__,params_i__);
181: 
182:         T__ e;
183:         (void) e;   // dummy to suppress unused var warning
184:         if (jacobian__)
185:             e = in__.scalar_constrain(lp__);
186:         else
187:             e = in__.scalar_constrain();
188: 
189:         T__ l;
190:         (void) l;   // dummy to suppress unused var warning
191:         if (jacobian__)
192:             l = in__.scalar_constrain(lp__);
193:         else
194:             l = in__.scalar_constrain();
195: 
196:         T__ sigma;
197:         (void) sigma;   // dummy to suppress unused var warning
198:         if (jacobian__)
199:             sigma = in__.scalar_lb_constrain(0,lp__);
200:         else
201:             sigma = in__.scalar_lb_constrain(0);
202: 
203: 
204:         // transformed parameters
205:         Eigen::Matrix<T__,Eigen::Dynamic,1>  lp(T);
206:         (void) lp;  // dummy to suppress unused var warning
207:         stan::math::fill(lp,DUMMY_VAR__);
208: 
209:         // initialize transformed variables to avoid seg fault on val access
210:         stan::math::fill(lp,DUMMY_VAR__);
211: 
212:         try {
213:             current_statement_begin__ = 21;
214:             stan::math::assign(lp, rep_vector(log_unif,T));
215:             current_statement_begin__ = 22;
216:             for (int s = 1; s <= T; ++s) {
217:                 current_statement_begin__ = 23;
218:                 for (int t = 1; t <= T; ++t) {
219:                     current_statement_begin__ = 24;
220:                     stan::math::assign(get_base1_lhs(lp,s,"lp",1), (get_base1(lp,s,"lp",1) + normal_log(get_base1(D,t,"D",1),if_else(logical_lt(t,s),(t * e),((s * e) + ((t - s) * l))),sigma)));
221:                 }
222:             }
223:         } catch (const std::exception& e) {
224:             stan::lang::rethrow_located(e,current_statement_begin__);
225:             // Next line prevents compiler griping about no return
226: throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
227:         }
228: 
229:         // validate transformed parameters
230:         for (int i0__ = 0; i0__ < T; ++i0__) {
231:             if (stan::math::is_uninitialized(lp(i0__))) {
232:                 std::stringstream msg__;
233:                 msg__ << "Undefined transformed parameter: lp" << '[' << i0__ << ']';
234:                 throw std::runtime_error(msg__.str());
235:             }
236:         }
237: 
238:         const char* function__ = "validate transformed params";
239:         (void) function__; // dummy to suppress unused var warning
240: 
241:         // model body
242:         try {
243:             current_statement_begin__ = 28;
244:             lp_accum__.add(normal_log<propto__>(e, r_e, 10));
245:             current_statement_begin__ = 29;
246:             lp_accum__.add(normal_log<propto__>(l, r_l, 10));
247:             current_statement_begin__ = 30;
248:             lp_accum__.add(normal_log<propto__>(sigma, 20, 10));
249:             current_statement_begin__ = 31;
250:             lp_accum__.add(log_sum_exp(lp));
251:         } catch (const std::exception& e) {
252:             stan::lang::rethrow_located(e,current_statement_begin__);
253:             // Next line prevents compiler griping about no return
254: throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
255:         }
256: 
257:         lp_accum__.add(lp__);
258:         return lp_accum__.sum();
259: 
260:     } // log_prob()
261: 
262:     template <bool propto, bool jacobian, typename T_>
263:     T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
264:                std::ostream* pstream = 0) const {
265:       std::vector<T_> vec_params_r;
266:       vec_params_r.reserve(params_r.size());
267:       for (int i = 0; i < params_r.size(); ++i)
268:         vec_params_r.push_back(params_r(i));
269:       std::vector<int> vec_params_i;
270:       return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
271:     }
272: 
273: 
274:     void get_param_names(std::vector<std::string>& names__) const {
275:         names__.resize(0);
276:         names__.push_back("e");
277:         names__.push_back("l");
278:         names__.push_back("sigma");
279:         names__.push_back("lp");
280:         names__.push_back("s");
281:     }
282: 
283: 
284:     void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
285:         dimss__.resize(0);
286:         std::vector<size_t> dims__;
287:         dims__.resize(0);
288:         dimss__.push_back(dims__);
289:         dims__.resize(0);
290:         dimss__.push_back(dims__);
291:         dims__.resize(0);
292:         dimss__.push_back(dims__);
293:         dims__.resize(0);
294:         dims__.push_back(T);
295:         dimss__.push_back(dims__);
296:         dims__.resize(0);
297:         dimss__.push_back(dims__);
298:     }
299: 
300:     template <typename RNG>
301:     void write_array(RNG& base_rng__,
302:                      std::vector<double>& params_r__,
303:                      std::vector<int>& params_i__,
304:                      std::vector<double>& vars__,
305:                      bool include_tparams__ = true,
306:                      bool include_gqs__ = true,
307:                      std::ostream* pstream__ = 0) const {
308:         vars__.resize(0);
309:         stan::io::reader<double> in__(params_r__,params_i__);
310:         static const char* function__ = "modelc9c67a11ebb_Model_changePointContinuous_namespace::write_array";
311:         (void) function__; // dummy call to supress warning
312:         // read-transform, write parameters
313:         double e = in__.scalar_constrain();
314:         double l = in__.scalar_constrain();
315:         double sigma = in__.scalar_lb_constrain(0);
316:         vars__.push_back(e);
317:         vars__.push_back(l);
318:         vars__.push_back(sigma);
319: 
320:         if (!include_tparams__) return;
321:         // declare and define transformed parameters
322:         double lp__ = 0.0;
323:         (void) lp__; // dummy call to supress warning
324:         stan::math::accumulator<double> lp_accum__;
325: 
326:         vector_d lp(T);
327:         (void) lp;  // dummy to suppress unused var warning
328: 
329:         try {
330:             current_statement_begin__ = 21;
331:             stan::math::assign(lp, rep_vector(log_unif,T));
332:             current_statement_begin__ = 22;
333:             for (int s = 1; s <= T; ++s) {
334:                 current_statement_begin__ = 23;
335:                 for (int t = 1; t <= T; ++t) {
336:                     current_statement_begin__ = 24;
337:                     stan::math::assign(get_base1_lhs(lp,s,"lp",1), (get_base1(lp,s,"lp",1) + normal_log(get_base1(D,t,"D",1),if_else(logical_lt(t,s),(t * e),((s * e) + ((t - s) * l))),sigma)));
338:                 }
339:             }
340:         } catch (const std::exception& e) {
341:             stan::lang::rethrow_located(e,current_statement_begin__);
342:             // Next line prevents compiler griping about no return
343: throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
344:         }
345: 
346:         // validate transformed parameters
347: 
348:         // write transformed parameters
349:         for (int k_0__ = 0; k_0__ < T; ++k_0__) {
350:             vars__.push_back(lp[k_0__]);
351:         }
352: 
353:         if (!include_gqs__) return;
354:         // declare and define generated quantities
355:         int s(0);
356:         (void) s;  // dummy to suppress unused var warning
357: 
358:         double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
359:         (void) DUMMY_VAR__;  // suppress unused var warning
360: 
361: 
362:         // initialize transformed variables to avoid seg fault on val access
363:         stan::math::fill(s,DUMMY_VAR__);
364: 
365:         try {
366:             current_statement_begin__ = 36;
367:             stan::math::assign(s, categorical_rng(softmax(lp), base_rng__));
368:         } catch (const std::exception& e) {
369:             stan::lang::rethrow_located(e,current_statement_begin__);
370:             // Next line prevents compiler griping about no return
371: throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
372:         }
373: 
374:         // validate generated quantities
375:         check_greater_or_equal(function__,"s",s,1);
376:         check_less_or_equal(function__,"s",s,T);
377: 
378:         // write generated quantities
379:         vars__.push_back(s);
380: 
381:     }
382: 
383:     template <typename RNG>
384:     void write_array(RNG& base_rng,
385:                      Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
386:                      Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
387:                      bool include_tparams = true,
388:                      bool include_gqs = true,
389:                      std::ostream* pstream = 0) const {
390:       std::vector<double> params_r_vec(params_r.size());
391:       for (int i = 0; i < params_r.size(); ++i)
392:         params_r_vec[i] = params_r(i);
393:       std::vector<double> vars_vec;
394:       std::vector<int> params_i_vec;
395:       write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
396:       vars.resize(vars_vec.size());
397:       for (int i = 0; i < vars.size(); ++i)
398:         vars(i) = vars_vec[i];
399:     }
400: 
401:     static std::string model_name() {
402:         return "modelc9c67a11ebb_Model_changePointContinuous";
403:     }
404: 
405: 
406:     void constrained_param_names(std::vector<std::string>& param_names__,
407:                                  bool include_tparams__ = true,
408:                                  bool include_gqs__ = true) const {
409:         std::stringstream param_name_stream__;
410:         param_name_stream__.str(std::string());
411:         param_name_stream__ << "e";
412:         param_names__.push_back(param_name_stream__.str());
413:         param_name_stream__.str(std::string());
414:         param_name_stream__ << "l";
415:         param_names__.push_back(param_name_stream__.str());
416:         param_name_stream__.str(std::string());
417:         param_name_stream__ << "sigma";
418:         param_names__.push_back(param_name_stream__.str());
419: 
420:         if (!include_gqs__ && !include_tparams__) return;
421:         for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
422:             param_name_stream__.str(std::string());
423:             param_name_stream__ << "lp" << '.' << k_0__;
424:             param_names__.push_back(param_name_stream__.str());
425:         }
426: 
427:         if (!include_gqs__) return;
428:         param_name_stream__.str(std::string());
429:         param_name_stream__ << "s";
430:         param_names__.push_back(param_name_stream__.str());
431:     }
432: 
433: 
434:     void unconstrained_param_names(std::vector<std::string>& param_names__,
435:                                    bool include_tparams__ = true,
436:                                    bool include_gqs__ = true) const {
437:         std::stringstream param_name_stream__;
438:         param_name_stream__.str(std::string());
439:         param_name_stream__ << "e";
440:         param_names__.push_back(param_name_stream__.str());
441:         param_name_stream__.str(std::string());
442:         param_name_stream__ << "l";
443:         param_names__.push_back(param_name_stream__.str());
444:         param_name_stream__.str(std::string());
445:         param_name_stream__ << "sigma";
446:         param_names__.push_back(param_name_stream__.str());
447: 
448:         if (!include_gqs__ && !include_tparams__) return;
449:         for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
450:             param_name_stream__.str(std::string());
451:             param_name_stream__ << "lp" << '.' << k_0__;
452:             param_names__.push_back(param_name_stream__.str());
453:         }
454: 
455:         if (!include_gqs__) return;
456:         param_name_stream__.str(std::string());
457:         param_name_stream__ << "s";
458:         param_names__.push_back(param_name_stream__.str());
459:     }
460: 
461: }; // model
462: 
463: } // namespace
464: 
465: typedef modelc9c67a11ebb_Model_changePointContinuous_namespace::modelc9c67a11ebb_Model_changePointContinuous stan_model;
466: 
467: #include <rstan/rstaninc.hpp>
468: /**
469:  * Define Rcpp Module to expose stan_fit's functions to R.
470:  */
471: RCPP_MODULE(stan_fit4modelc9c67a11ebb_Model_changePointContinuous_mod){
472:   Rcpp::class_<rstan::stan_fit<modelc9c67a11ebb_Model_changePointContinuous_namespace::modelc9c67a11ebb_Model_changePointContinuous,
473:                boost::random::ecuyer1988> >("stan_fit4modelc9c67a11ebb_Model_changePointContinuous")
474:     // .constructor<Rcpp::List>()
475:     .constructor<SEXP, SEXP>()
476:     // .constructor<SEXP, SEXP>()
477:     .method("call_sampler",
478:             &rstan::stan_fit<modelc9c67a11ebb_Model_changePointContinuous_namespace::modelc9c67a11ebb_Model_changePointContinuous, boost::random::ecuyer1988>::call_sampler)
479:     .method("param_names",
480:             &rstan::stan_fit<modelc9c67a11ebb_Model_changePointContinuous_namespace::modelc9c67a11ebb_Model_changePointContinuous, boost::random::ecuyer1988>::param_names)
481:     .method("param_names_oi",
482:             &rstan::stan_fit<modelc9c67a11ebb_Model_changePointContinuous_namespace::modelc9c67a11ebb_Model_changePointContinuous, boost::random::ecuyer1988>::param_names_oi)
483:     .method("param_fnames_oi",
484:             &rstan::stan_fit<modelc9c67a11ebb_Model_changePointContinuous_namespace::modelc9c67a11ebb_Model_changePointContinuous, boost::random::ecuyer1988>::param_fnames_oi)
485:     .method("param_dims",
486:             &rstan::stan_fit<modelc9c67a11ebb_Model_changePointContinuous_namespace::modelc9c67a11ebb_Model_changePointContinuous, boost::random::ecuyer1988>::param_dims)
487:     .method("param_dims_oi",
488:             &rstan::stan_fit<modelc9c67a11ebb_Model_changePointContinuous_namespace::modelc9c67a11ebb_Model_changePointContinuous, boost::random::ecuyer1988>::param_dims_oi)
489:     .method("update_param_oi",
490:             &rstan::stan_fit<modelc9c67a11ebb_Model_changePointContinuous_namespace::modelc9c67a11ebb_Model_changePointContinuous, boost::random::ecuyer1988>::update_param_oi)
491:     .method("param_oi_tidx",
492:             &rstan::stan_fit<modelc9c67a11ebb_Model_changePointContinuous_namespace::modelc9c67a11ebb_Model_changePointContinuous, boost::random::ecuyer1988>::param_oi_tidx)
493:     .method("grad_log_prob",
494:             &rstan::stan_fit<modelc9c67a11ebb_Model_changePointContinuous_namespace::modelc9c67a11ebb_Model_changePointContinuous, boost::random::ecuyer1988>::grad_log_prob)
495:     .method("log_prob",
496:             &rstan::stan_fit<modelc9c67a11ebb_Model_changePointContinuous_namespace::modelc9c67a11ebb_Model_changePointContinuous, boost::random::ecuyer1988>::log_prob)
497:     .method("unconstrain_pars",
498:             &rstan::stan_fit<modelc9c67a11ebb_Model_changePointContinuous_namespace::modelc9c67a11ebb_Model_changePointContinuous, boost::random::ecuyer1988>::unconstrain_pars)
499:     .method("constrain_pars",
500:             &rstan::stan_fit<modelc9c67a11ebb_Model_changePointContinuous_namespace::modelc9c67a11ebb_Model_changePointContinuous, boost::random::ecuyer1988>::constrain_pars)
501:     .method("num_pars_unconstrained",
502:             &rstan::stan_fit<modelc9c67a11ebb_Model_changePointContinuous_namespace::modelc9c67a11ebb_Model_changePointContinuous, boost::random::ecuyer1988>::num_pars_unconstrained)
503:     .method("unconstrained_param_names",
504:             &rstan::stan_fit<modelc9c67a11ebb_Model_changePointContinuous_namespace::modelc9c67a11ebb_Model_changePointContinuous, boost::random::ecuyer1988>::unconstrained_param_names)
505:     .method("constrained_param_names",
506:             &rstan::stan_fit<modelc9c67a11ebb_Model_changePointContinuous_namespace::modelc9c67a11ebb_Model_changePointContinuous, boost::random::ecuyer1988>::constrained_param_names)
507:     ;
508: }
509: 
510: // declarations
511: extern "C" {
512: SEXP filec9c6965573f( ) ;
513: }
514: 
515: // definition
516: 
517: SEXP filec9c6965573f(  ){
518:  return Rcpp::wrap("Model_changePointContinuous");
519: }
520: 
521: 
Error in compileCode(f, code, language = language, verbose = verbose) : 
  Compilation ERROR, function(s)/method(s) not created!       1 [main] make (984) c:\Rtools\bin\make.exe: *** fatal error - cygheap base mismatch detected - 0xC47408/0xBB7408.
This problem is probably due to using incompatible versions of the cygwin DLL.
Search for cygwin1.dll using the Windows Start->Find/Search facility
and delete all but the most recent version.  The most recent version *should*
reside in x:\cygwin\bin, where 'x' is the drive on which you have
installed the cygwin distribution.  Rebooting is also suggested if you
are unable to find another cygwin DLL.
      1 [main] make 5600 fork: child -1 - forked process 984 died unexpectedly, retry 0, exit code 0xC0000142, errno 11
make: vfork: Resource temporarily unavailable
Warning message:
running command 'make -f "C:/PROGRA~1/R/R-32~1.3/etc/x64/Makeconf" -f "C:/PROGRA~1/R/R-32~1.3/share/make/winshlib.mk" SHLIB_LDFLAGS='$(SHLIB_CXXLDFLAGS)' SHLIB_LD='$(SHLIB_CXXLD)' SHLIB="filec9c6965573f.dll" WIN=64 TCLBIN=64 OBJECT
In addition: Warning message:
running command 'C:/PROGRA~1/R/R-32~1.3/bin/x64/R CMD SHLIB filec9c6965573f.cpp 2> filec9c6965573f.cpp.err.txt' had status 1 