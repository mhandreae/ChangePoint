> MarginalChangePoint5 <- stan(file = 'Model_changePointContinuous5.stan',
+ data= continuous_data,
+ iter = 10, chains = 4)
      1 [main] make (3684) c:\Rtools\bin\make.exe: *** fatal error - cygheap base mismatch detected - 0xBC7408/0xB67408.
This problem is probably due to using incompatible versions of the cygwin DLL.
Search for cygwin1.dll using the Windows Start->Find/Search facility
and delete all but the most recent version.  The most recent version *should*
reside in x:\cygwin\bin, where 'x' is the drive on which you have
installed the cygwin distribution.  Rebooting is also suggested if you
are unable to find another cygwin DLL.
      1 [main] make 2192 fork: child -1 - forked process 3684 died unexpectedly, retry 0, exit code 0xC0000142, errno 11
make: vfork: Resource temporarily unavailable
Warning message:
running command 'make -f "C:/PROGRA~1/R/R-32~1.3/etc/x64/Makeconf" -f "C:/PROGRA~1/R/R-32~1.3/share/make/winshlib.mk" SHLIB_LDFLAGS='$(SHLIB_CXXLDFLAGS)' SHLIB_LD='$(SHLIB_CXXLD)' SHLIB="file1078297513e2.dll" WIN=64 TCLBIN=64 OBJECTS="file1078297513e2.o"' had status 2 

ERROR(s) during compilation: source code errors or compiler configuration errors!

Program source:
  1: 
  2: // includes from the plugin
  3: 
  4: 
  5: // user includes
  6: #define STAN__SERVICES__COMMAND_HPP// Code generated by Stan version 2.9
  7: 
  8: #include <stan/model/model_header.hpp>
  9: 
 10: namespace model107845e669e0_Model_changePointContinuous5_namespace {
 11: 
 12: using std::istream;
 13: using std::string;
 14: using std::stringstream;
 15: using std::vector;
 16: using stan::io::dump;
 17: using stan::math::lgamma;
 18: using stan::model::prob_grad;
 19: using namespace stan::math;
 20: 
 21: typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
 22: typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
 23: typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;
 24: 
 25: static int current_statement_begin__;
 26: class model107845e669e0_Model_changePointContinuous5 : public prob_grad {
 27: private:
 28:     double r_e;
 29:     double r_l;
 30:     int T;
 31:     vector<int> observed;
 32:     vector<double> D;
 33:     double log_unif;
 34: public:
 35:     model107845e669e0_Model_changePointContinuous5(stan::io::var_context& context__,
 36:         std::ostream* pstream__ = 0)
 37:         : prob_grad(0) {
 38:         current_statement_begin__ = -1;
 39: 
 40:         static const char* function__ = "model107845e669e0_Model_changePointContinuous5_namespace::model107845e669e0_Model_changePointContinuous5";
 41:         (void) function__; // dummy call to supress warning
 42:         size_t pos__;
 43:         (void) pos__; // dummy call to supress warning
 44:         std::vector<int> vals_i__;
 45:         std::vector<double> vals_r__;
 46:         context__.validate_dims("data initialization", "r_e", "double", context__.to_vec());
 47:         r_e = double(0);
 48:         vals_r__ = context__.vals_r("r_e");
 49:         pos__ = 0;
 50:         r_e = vals_r__[pos__++];
 51:         context__.validate_dims("data initialization", "r_l", "double", context__.to_vec());
 52:         r_l = double(0);
 53:         vals_r__ = context__.vals_r("r_l");
 54:         pos__ = 0;
 55:         r_l = vals_r__[pos__++];
 56:         context__.validate_dims("data initialization", "T", "int", context__.to_vec());
 57:         T = int(0);
 58:         vals_i__ = context__.vals_i("T");
 59:         pos__ = 0;
 60:         T = vals_i__[pos__++];
 61:         context__.validate_dims("data initialization", "observed", "int", context__.to_vec(T));
 62:         validate_non_negative_index("observed", "T", T);
 63:         observed = std::vector<int>(T,int(0));
 64:         vals_i__ = context__.vals_i("observed");
 65:         pos__ = 0;
 66:         size_t observed_limit_0__ = T;
 67:         for (size_t i_0__ = 0; i_0__ < observed_limit_0__; ++i_0__) {
 68:             observed[i_0__] = vals_i__[pos__++];
 69:         }
 70:         context__.validate_dims("data initialization", "D", "double", context__.to_vec(T));
 71:         validate_non_negative_index("D", "T", T);
 72:         D = std::vector<double>(T,double(0));
 73:         vals_r__ = context__.vals_r("D");
 74:         pos__ = 0;
 75:         size_t D_limit_0__ = T;
 76:         for (size_t i_0__ = 0; i_0__ < D_limit_0__; ++i_0__) {
 77:             D[i_0__] = vals_r__[pos__++];
 78:         }
 79: 
 80:         // validate data
 81:         check_greater_or_equal(function__,"T",T,1);
 82:         for (int k0__ = 0; k0__ < T; ++k0__) {
 83:             check_greater_or_equal(function__,"observed[k0__]",observed[k0__],1);
 84:         }
 85:         log_unif = double(0);
 86: 
 87:         double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 88:         (void) DUMMY_VAR__;  // suppress unused var warning
 89: 
 90: 
 91:         // initialize transformed variables to avoid seg fault on val access
 92:         stan::math::fill(log_unif,DUMMY_VAR__);
 93: 
 94:         try {
 95:             current_statement_begin__ = 11;
 96:             stan::math::assign(log_unif, -(log(T)));
 97:         } catch (const std::exception& e) {
 98:             stan::lang::rethrow_located(e,current_statement_begin__);
 99:             // Next line prevents compiler griping about no return
100: throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
101:         }
102: 
103:         // validate transformed data
104: 
105:         // set parameter ranges
106:         num_params_r__ = 0U;
107:         param_ranges_i__.clear();
108:         ++num_params_r__;
109:         ++num_params_r__;
110:         ++num_params_r__;
111:     }
112: 
113:     ~model107845e669e0_Model_changePointContinuous5() { }
114: 
115: 
116:     void transform_inits(const stan::io::var_context& context__,
117:                          std::vector<int>& params_i__,
118:                          std::vector<double>& params_r__,
119:                          std::ostream* pstream__) const {
120:         stan::io::writer<double> writer__(params_r__,params_i__);
121:         size_t pos__;
122:         (void) pos__; // dummy call to supress warning
123:         std::vector<double> vals_r__;
124:         std::vector<int> vals_i__;
125: 
126:         if (!(context__.contains_r("e")))
127:             throw std::runtime_error("variable e missing");
128:         vals_r__ = context__.vals_r("e");
129:         pos__ = 0U;
130:         context__.validate_dims("initialization", "e", "double", context__.to_vec());
131:         double e(0);
132:         e = vals_r__[pos__++];
133:         try {
134:             writer__.scalar_unconstrain(e);
135:         } catch (const std::exception& e) { 
136:             throw std::runtime_error(std::string("Error transforming variable e: ") + e.what());
137:         }
138: 
139:         if (!(context__.contains_r("l")))
140:             throw std::runtime_error("variable l missing");
141:         vals_r__ = context__.vals_r("l");
142:         pos__ = 0U;
143:         context__.validate_dims("initialization", "l", "double", context__.to_vec());
144:         double l(0);
145:         l = vals_r__[pos__++];
146:         try {
147:             writer__.scalar_unconstrain(l);
148:         } catch (const std::exception& e) { 
149:             throw std::runtime_error(std::string("Error transforming variable l: ") + e.what());
150:         }
151: 
152:         if (!(context__.contains_r("sigma")))
153:             throw std::runtime_error("variable sigma missing");
154:         vals_r__ = context__.vals_r("sigma");
155:         pos__ = 0U;
156:         context__.validate_dims("initialization", "sigma", "double", context__.to_vec());
157:         double sigma(0);
158:         sigma = vals_r__[pos__++];
159:         try {
160:             writer__.scalar_lb_unconstrain(0,sigma);
161:         } catch (const std::exception& e) { 
162:             throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
163:         }
164: 
165:         params_r__ = writer__.data_r();
166:         params_i__ = writer__.data_i();
167:     }
168: 
169:     void transform_inits(const stan::io::var_context& context,
170:                          Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
171:                          std::ostream* pstream__) const {
172:       std::vector<double> params_r_vec;
173:       std::vector<int> params_i_vec;
174:       transform_inits(context, params_i_vec, params_r_vec, pstream__);
175:       params_r.resize(params_r_vec.size());
176:       for (int i = 0; i < params_r.size(); ++i)
177:         params_r(i) = params_r_vec[i];
178:     }
179: 
180: 
181:     template <bool propto__, bool jacobian__, typename T__>
182:     T__ log_prob(vector<T__>& params_r__,
183:                  vector<int>& params_i__,
184:                  std::ostream* pstream__ = 0) const {
185: 
186:         T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
187:         (void) DUMMY_VAR__;  // suppress unused var warning
188: 
189:         T__ lp__(0.0);
190:         stan::math::accumulator<T__> lp_accum__;
191: 
192:         // model parameters
193:         stan::io::reader<T__> in__(params_r__,params_i__);
194: 
195:         T__ e;
196:         (void) e;   // dummy to suppress unused var warning
197:         if (jacobian__)
198:             e = in__.scalar_constrain(lp__);
199:         else
200:             e = in__.scalar_constrain();
201: 
202:         T__ l;
203:         (void) l;   // dummy to suppress unused var warning
204:         if (jacobian__)
205:             l = in__.scalar_constrain(lp__);
206:         else
207:             l = in__.scalar_constrain();
208: 
209:         T__ sigma;
210:         (void) sigma;   // dummy to suppress unused var warning
211:         if (jacobian__)
212:             sigma = in__.scalar_lb_constrain(0,lp__);
213:         else
214:             sigma = in__.scalar_lb_constrain(0);
215: 
216: 
217:         // transformed parameters
218:         Eigen::Matrix<T__,Eigen::Dynamic,1>  lp(T);
219:         (void) lp;  // dummy to suppress unused var warning
220:         stan::math::fill(lp,DUMMY_VAR__);
221: 
222:         // initialize transformed variables to avoid seg fault on val access
223:         stan::math::fill(lp,DUMMY_VAR__);
224: 
225:         try {
226:             current_statement_begin__ = 22;
227:             stan::math::assign(lp, rep_vector(log_unif,T));
228:             current_statement_begin__ = 23;
229:             for (int s = 1; s <= T; ++s) {
230:                 current_statement_begin__ = 24;
231:                 for (int t = 1; t <= T; ++t) {
232:                     current_statement_begin__ = 25;
233:                     stan::math::assign(get_base1_lhs(lp,s,"lp",1), (get_base1(lp,s,"lp",1) + normal_log(D,if_else(logical_lt(get_base1(observed,t,"observed",1),s),(get_base1(observed,t,"observed",1) * e),((s * e) + ((get_base1(observed,t,"observed",1) - s) * l))),sigma)));
234:                 }
235:             }
236:         } catch (const std::exception& e) {
237:             stan::lang::rethrow_located(e,current_statement_begin__);
238:             // Next line prevents compiler griping about no return
239: throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
240:         }
241: 
242:         // validate transformed parameters
243:         for (int i0__ = 0; i0__ < T; ++i0__) {
244:             if (stan::math::is_uninitialized(lp(i0__))) {
245:                 std::stringstream msg__;
246:                 msg__ << "Undefined transformed parameter: lp" << '[' << i0__ << ']';
247:                 throw std::runtime_error(msg__.str());
248:             }
249:         }
250: 
251:         const char* function__ = "validate transformed params";
252:         (void) function__; // dummy to suppress unused var warning
253: 
254:         // model body
255:         try {
256:             current_statement_begin__ = 29;
257:             lp_accum__.add(normal_log<propto__>(e, r_e, 10));
258:             current_statement_begin__ = 30;
259:             lp_accum__.add(normal_log<propto__>(l, r_l, 10));
260:             current_statement_begin__ = 31;
261:             lp_accum__.add(normal_log<propto__>(sigma, 20, 10));
262:             current_statement_begin__ = 32;
263:             lp_accum__.add(log_sum_exp(lp));
264:         } catch (const std::exception& e) {
265:             stan::lang::rethrow_located(e,current_statement_begin__);
266:             // Next line prevents compiler griping about no return
267: throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
268:         }
269: 
270:         lp_accum__.add(lp__);
271:         return lp_accum__.sum();
272: 
273:     } // log_prob()
274: 
275:     template <bool propto, bool jacobian, typename T_>
276:     T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
277:                std::ostream* pstream = 0) const {
278:       std::vector<T_> vec_params_r;
279:       vec_params_r.reserve(params_r.size());
280:       for (int i = 0; i < params_r.size(); ++i)
281:         vec_params_r.push_back(params_r(i));
282:       std::vector<int> vec_params_i;
283:       return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
284:     }
285: 
286: 
287:     void get_param_names(std::vector<std::string>& names__) const {
288:         names__.resize(0);
289:         names__.push_back("e");
290:         names__.push_back("l");
291:         names__.push_back("sigma");
292:         names__.push_back("lp");
293:         names__.push_back("s");
294:     }
295: 
296: 
297:     void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
298:         dimss__.resize(0);
299:         std::vector<size_t> dims__;
300:         dims__.resize(0);
301:         dimss__.push_back(dims__);
302:         dims__.resize(0);
303:         dimss__.push_back(dims__);
304:         dims__.resize(0);
305:         dimss__.push_back(dims__);
306:         dims__.resize(0);
307:         dims__.push_back(T);
308:         dimss__.push_back(dims__);
309:         dims__.resize(0);
310:         dimss__.push_back(dims__);
311:     }
312: 
313:     template <typename RNG>
314:     void write_array(RNG& base_rng__,
315:                      std::vector<double>& params_r__,
316:                      std::vector<int>& params_i__,
317:                      std::vector<double>& vars__,
318:                      bool include_tparams__ = true,
319:                      bool include_gqs__ = true,
320:                      std::ostream* pstream__ = 0) const {
321:         vars__.resize(0);
322:         stan::io::reader<double> in__(params_r__,params_i__);
323:         static const char* function__ = "model107845e669e0_Model_changePointContinuous5_namespace::write_array";
324:         (void) function__; // dummy call to supress warning
325:         // read-transform, write parameters
326:         double e = in__.scalar_constrain();
327:         double l = in__.scalar_constrain();
328:         double sigma = in__.scalar_lb_constrain(0);
329:         vars__.push_back(e);
330:         vars__.push_back(l);
331:         vars__.push_back(sigma);
332: 
333:         if (!include_tparams__) return;
334:         // declare and define transformed parameters
335:         double lp__ = 0.0;
336:         (void) lp__; // dummy call to supress warning
337:         stan::math::accumulator<double> lp_accum__;
338: 
339:         vector_d lp(T);
340:         (void) lp;  // dummy to suppress unused var warning
341: 
342:         try {
343:             current_statement_begin__ = 22;
344:             stan::math::assign(lp, rep_vector(log_unif,T));
345:             current_statement_begin__ = 23;
346:             for (int s = 1; s <= T; ++s) {
347:                 current_statement_begin__ = 24;
348:                 for (int t = 1; t <= T; ++t) {
349:                     current_statement_begin__ = 25;
350:                     stan::math::assign(get_base1_lhs(lp,s,"lp",1), (get_base1(lp,s,"lp",1) + normal_log(D,if_else(logical_lt(get_base1(observed,t,"observed",1),s),(get_base1(observed,t,"observed",1) * e),((s * e) + ((get_base1(observed,t,"observed",1) - s) * l))),sigma)));
351:                 }
352:             }
353:         } catch (const std::exception& e) {
354:             stan::lang::rethrow_located(e,current_statement_begin__);
355:             // Next line prevents compiler griping about no return
356: throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
357:         }
358: 
359:         // validate transformed parameters
360: 
361:         // write transformed parameters
362:         for (int k_0__ = 0; k_0__ < T; ++k_0__) {
363:             vars__.push_back(lp[k_0__]);
364:         }
365: 
366:         if (!include_gqs__) return;
367:         // declare and define generated quantities
368:         int s(0);
369:         (void) s;  // dummy to suppress unused var warning
370: 
371:         double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
372:         (void) DUMMY_VAR__;  // suppress unused var warning
373: 
374: 
375:         // initialize transformed variables to avoid seg fault on val access
376:         stan::math::fill(s,DUMMY_VAR__);
377: 
378:         try {
379:             current_statement_begin__ = 37;
380:             stan::math::assign(s, categorical_rng(softmax(lp), base_rng__));
381:         } catch (const std::exception& e) {
382:             stan::lang::rethrow_located(e,current_statement_begin__);
383:             // Next line prevents compiler griping about no return
384: throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
385:         }
386: 
387:         // validate generated quantities
388:         check_greater_or_equal(function__,"s",s,1);
389:         check_less_or_equal(function__,"s",s,T);
390: 
391:         // write generated quantities
392:         vars__.push_back(s);
393: 
394:     }
395: 
396:     template <typename RNG>
397:     void write_array(RNG& base_rng,
398:                      Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
399:                      Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
400:                      bool include_tparams = true,
401:                      bool include_gqs = true,
402:                      std::ostream* pstream = 0) const {
403:       std::vector<double> params_r_vec(params_r.size());
404:       for (int i = 0; i < params_r.size(); ++i)
405:         params_r_vec[i] = params_r(i);
406:       std::vector<double> vars_vec;
407:       std::vector<int> params_i_vec;
408:       write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
409:       vars.resize(vars_vec.size());
410:       for (int i = 0; i < vars.size(); ++i)
411:         vars(i) = vars_vec[i];
412:     }
413: 
414:     static std::string model_name() {
415:         return "model107845e669e0_Model_changePointContinuous5";
416:     }
417: 
418: 
419:     void constrained_param_names(std::vector<std::string>& param_names__,
420:                                  bool include_tparams__ = true,
421:                                  bool include_gqs__ = true) const {
422:         std::stringstream param_name_stream__;
423:         param_name_stream__.str(std::string());
424:         param_name_stream__ << "e";
425:         param_names__.push_back(param_name_stream__.str());
426:         param_name_stream__.str(std::string());
427:         param_name_stream__ << "l";
428:         param_names__.push_back(param_name_stream__.str());
429:         param_name_stream__.str(std::string());
430:         param_name_stream__ << "sigma";
431:         param_names__.push_back(param_name_stream__.str());
432: 
433:         if (!include_gqs__ && !include_tparams__) return;
434:         for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
435:             param_name_stream__.str(std::string());
436:             param_name_stream__ << "lp" << '.' << k_0__;
437:             param_names__.push_back(param_name_stream__.str());
438:         }
439: 
440:         if (!include_gqs__) return;
441:         param_name_stream__.str(std::string());
442:         param_name_stream__ << "s";
443:         param_names__.push_back(param_name_stream__.str());
444:     }
445: 
446: 
447:     void unconstrained_param_names(std::vector<std::string>& param_names__,
448:                                    bool include_tparams__ = true,
449:                                    bool include_gqs__ = true) const {
450:         std::stringstream param_name_stream__;
451:         param_name_stream__.str(std::string());
452:         param_name_stream__ << "e";
453:         param_names__.push_back(param_name_stream__.str());
454:         param_name_stream__.str(std::string());
455:         param_name_stream__ << "l";
456:         param_names__.push_back(param_name_stream__.str());
457:         param_name_stream__.str(std::string());
458:         param_name_stream__ << "sigma";
459:         param_names__.push_back(param_name_stream__.str());
460: 
461:         if (!include_gqs__ && !include_tparams__) return;
462:         for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
463:             param_name_stream__.str(std::string());
464:             param_name_stream__ << "lp" << '.' << k_0__;
465:             param_names__.push_back(param_name_stream__.str());
466:         }
467: 
468:         if (!include_gqs__) return;
469:         param_name_stream__.str(std::string());
470:         param_name_stream__ << "s";
471:         param_names__.push_back(param_name_stream__.str());
472:     }
473: 
474: }; // model
475: 
476: } // namespace
477: 
478: typedef model107845e669e0_Model_changePointContinuous5_namespace::model107845e669e0_Model_changePointContinuous5 stan_model;
479: 
480: #include <rstan/rstaninc.hpp>
481: /**
482:  * Define Rcpp Module to expose stan_fit's functions to R.
483:  */
484: RCPP_MODULE(stan_fit4model107845e669e0_Model_changePointContinuous5_mod){
485:   Rcpp::class_<rstan::stan_fit<model107845e669e0_Model_changePointContinuous5_namespace::model107845e669e0_Model_changePointContinuous5,
486:                boost::random::ecuyer1988> >("stan_fit4model107845e669e0_Model_changePointContinuous5")
487:     // .constructor<Rcpp::List>()
488:     .constructor<SEXP, SEXP>()
489:     // .constructor<SEXP, SEXP>()
490:     .method("call_sampler",
491:             &rstan::stan_fit<model107845e669e0_Model_changePointContinuous5_namespace::model107845e669e0_Model_changePointContinuous5, boost::random::ecuyer1988>::call_sampler)
492:     .method("param_names",
493:             &rstan::stan_fit<model107845e669e0_Model_changePointContinuous5_namespace::model107845e669e0_Model_changePointContinuous5, boost::random::ecuyer1988>::param_names)
494:     .method("param_names_oi",
495:             &rstan::stan_fit<model107845e669e0_Model_changePointContinuous5_namespace::model107845e669e0_Model_changePointContinuous5, boost::random::ecuyer1988>::param_names_oi)
496:     .method("param_fnames_oi",
497:             &rstan::stan_fit<model107845e669e0_Model_changePointContinuous5_namespace::model107845e669e0_Model_changePointContinuous5, boost::random::ecuyer1988>::param_fnames_oi)
498:     .method("param_dims",
499:             &rstan::stan_fit<model107845e669e0_Model_changePointContinuous5_namespace::model107845e669e0_Model_changePointContinuous5, boost::random::ecuyer1988>::param_dims)
500:     .method("param_dims_oi",
501:             &rstan::stan_fit<model107845e669e0_Model_changePointContinuous5_namespace::model107845e669e0_Model_changePointContinuous5, boost::random::ecuyer1988>::param_dims_oi)
502:     .method("update_param_oi",
503:             &rstan::stan_fit<model107845e669e0_Model_changePointContinuous5_namespace::model107845e669e0_Model_changePointContinuous5, boost::random::ecuyer1988>::update_param_oi)
504:     .method("param_oi_tidx",
505:             &rstan::stan_fit<model107845e669e0_Model_changePointContinuous5_namespace::model107845e669e0_Model_changePointContinuous5, boost::random::ecuyer1988>::param_oi_tidx)
506:     .method("grad_log_prob",
507:             &rstan::stan_fit<model107845e669e0_Model_changePointContinuous5_namespace::model107845e669e0_Model_changePointContinuous5, boost::random::ecuyer1988>::grad_log_prob)
508:     .method("log_prob",
509:             &rstan::stan_fit<model107845e669e0_Model_changePointContinuous5_namespace::model107845e669e0_Model_changePointContinuous5, boost::random::ecuyer1988>::log_prob)
510:     .method("unconstrain_pars",
511:             &rstan::stan_fit<model107845e669e0_Model_changePointContinuous5_namespace::model107845e669e0_Model_changePointContinuous5, boost::random::ecuyer1988>::unconstrain_pars)
512:     .method("constrain_pars",
513:             &rstan::stan_fit<model107845e669e0_Model_changePointContinuous5_namespace::model107845e669e0_Model_changePointContinuous5, boost::random::ecuyer1988>::constrain_pars)
514:     .method("num_pars_unconstrained",
515:             &rstan::stan_fit<model107845e669e0_Model_changePointContinuous5_namespace::model107845e669e0_Model_changePointContinuous5, boost::random::ecuyer1988>::num_pars_unconstrained)
516:     .method("unconstrained_param_names",
517:             &rstan::stan_fit<model107845e669e0_Model_changePointContinuous5_namespace::model107845e669e0_Model_changePointContinuous5, boost::random::ecuyer1988>::unconstrained_param_names)
518:     .method("constrained_param_names",
519:             &rstan::stan_fit<model107845e669e0_Model_changePointContinuous5_namespace::model107845e669e0_Model_changePointContinuous5, boost::random::ecuyer1988>::constrained_param_names)
520:     ;
521: }
522: 
523: // declarations
524: extern "C" {
525: SEXP file1078297513e2( ) ;
526: }
527: 
528: // definition
529: 
530: SEXP file1078297513e2(  ){
531:  return Rcpp::wrap("Model_changePointContinuous5");
532: }
533: 
534: 
Error in compileCode(f, code, language = language, verbose = verbose) : 
  Compilation ERROR, function(s)/method(s) not created!       1 [main] make (3684) c:\Rtools\bin\make.exe: *** fatal error - cygheap base mismatch detected - 0xBC7408/0xB67408.
This problem is probably due to using incompatible versions of the cygwin DLL.
Search for cygwin1.dll using the Windows Start->Find/Search facility
and delete all but the most recent version.  The most recent version *should*
reside in x:\cygwin\bin, where 'x' is the drive on which you have
installed the cygwin distribution.  Rebooting is also suggested if you
are unable to find another cygwin DLL.
      1 [main] make 2192 fork: child -1 - forked process 3684 died unexpectedly, retry 0, exit code 0xC0000142, errno 11
make: vfork: Resource temporarily unavailable
Warning message:
running command 'make -f "C:/PROGRA~1/R/R-32~1.3/etc/x64/Makeconf" -f "C:/PROGRA~1/R/R-32~1.3/share/make/winshlib.mk" SHLIB_LDFLAGS='$(SHLIB_CXXLDFLAGS)' SHLIB_LD='$(SHLIB_CXXLD)' SHLIB="file1078297513e2.dll" WIN=64 TCLBIN=64 OBJ
In addition: Warning message:
running command 'C:/PROGRA~1/R/R-32~1.3/bin/x64/R CMD SHLIB file1078297513e2.cpp 2> file1078297513e2.cpp.err.txt' had status 1 
> 